# ETHEREUM 102

## Summary

In this session, we dive deeper into keys, addresses and transactions

[Video](https://www.youtube.com/watch?v=zIeBfuXxuWs)

### Keys

- 2 keys in crypto - public and private keys
- Public keys are open to all - not secret
- Private key generates public key
- Public key is a point on elliptic curve generated by private key
- Public key cannot be used to derive private key → this is one way

---

### Ethereum state and accounts

- State is just a collection of accounts
- Each account is an object → has an address → a 20 byte address
- Account address helps in communicating with other accounts
- Each ethereum account has 4 fields
  - _Nonce_ - counter that keeps track of txns initiated by account
  - _Balance_ - amount of ether in the account
  - _Storage_ - all storage variables
  - _Code_ - contract code
- 2 types of accounts - EoA (externally owned accounts) and contract accounts
- Contract account is controlled by code that is within that account

---

### Externally Owned Account (EOA) account

- EoA is controlled by private key → private key can create a digital signature that can control account balance in that EoA

- EoA does NOT have any contract storage and contract code.
- It is controlled by a private key that is used to digitally sign messages originating from this account
- Messages can trigger a transaction (or a contract account) or they can transfer value

---

### Contract Account

- Contract account has nonce, balance, code and storage
- When a contract account receives a message, it runs a code, accesses storage and changes state of blockchain
- A contract account cannot initiate by itself - always needs to be triggered by EoA account
- When code runs, you can create messages, transfer value or create new contracts or trigger functions in a different contract

---

### Smart Contract

- Autonomous agents present on ethereum blockchain
- Ready to be triggered by EoA or other smart contracts
- Receive txn message that can trigger execution code present in their account

---

### Keccak 256

- Name of cryptographic hashing function used by ethereum
- Fundamental primitive for ethereum blockchain
- Public key is hashed using keccak256 cryptographic hash function → and last 20 bytes (least significant bytes) constitute the address (prefixed by ‘0x’)
- Address is a 160 bits or 20 bytes

---

### Transactions

- Transactions are signed messages that originate **outside** ethereum blockchain (outside is stressed..)
- Transaction origin is Externally owned account managed by a private key
- Transactions are transmitted via Ethereum Network
- Transactions trigger state changes which are also recorded on ethereum blockchain

**Properties**

- _Atomic_ - they run from beginning to end, all or nothing - cant be broken down or interrupted
- _Sequential_ - transactions don’t run in parallel - always one after another (no multi threads here)
- _Inclusion_ - who decides which transactions go to the next block - its a function of congestion of network (how many txns are competing) and gas price
- _Ordering_ - what order in which transactions are executed - again a function of congestion and gas price - manipulating order of txns leads to MEV

**Components**

Transaction is a serialized binary message that contain several components

- _Nonce_: transaction number that is unique to the specific account. used to prevent message replays; replaying same txn over and over again; nonce increases each time a message is signed
- _Gas Price_: price in wei per gas unit - _Gas Limit_: maximum gas used for txn
- _recepient_: destination address
- _value_: amount of ether in wei terms
- _data_: payload that is encoded
- _v,r,s_: ECDSA signature

Lets unpack the above components

- _Nonce_

  - Number used only once
  - Sequence number prevents replay attacks
  - If EOA, nonce is number of txns sent from the account

- _Gas Price_

  - Price originator is willing to pay
  - price is #wei/unit of gas
  - higher the price, faster the inclusion of a txn
  - price depends on demand for blockspace - blockspace is limited onchain

- _Gas Limit_

  - Max units sender is willing to pay for this txn
  - Depends on type and complexity of txn
  - If its a simple transfer, it costs 21000 gas for execution
  - Txn runs out of gas - that txn fails with ‘Out of Gas’ exception
  - Estimated gas is calculated & sent as part of txn → if estimated gas > actual gas, difference is sent back to the sender

- _Recepient_

  - 20 byte address of tx recipient
  - EOA address or a contract address
  - This address has no protocol validation → so you can send to an address that does not have a private key
  - **Ethereum in itself does not check if the address is valid or not → those checks should be done by sender or interface used by eoa**
  - Note that this is the target address - there is no ‘from’ address in a transaction. This is because ‘from’ address can be derived from ECDSA components (v, r, s) → give us public key → from which we get ‘from’ address

- _Value_
  - Represents value of ether sent by sender to receipient
  - If recepient is a EoA, balance of that account increases and sender balance decreases correspondingly
  - If its a contract function, what happens depends on ‘data’ (bytes data sent as part of transaction)
  - if ‘data’ points to a implementation within contract, data function will be executed and the value gets passed to that function (what happens there depends on nature of that function)
  - If contract function, and no ‘data’ is provided - > the `receive()/fallback()` functions inside the contract get triggered. What happens to the ‘value’ depends on the logic defined within these functions
- If target is a contract function, no data is provided and no `receive()` or `fallback()` functions are defined → leads to an exception. Transaction reverts and the sender balance never changes

- _Data_

  - bytes sent by the sender to the receiver
  - data is relevant when receipient is a contract account
  - `data` contains contract function that needs to be triggered along with relevant input arguments that are passed to that function

- _(v,r,s)_
  - ECDSA signature - it is 65 bytes in length
  - Has 3 sub components - `r, s` represent signature components - 32 bytes each
  - `v` - recovery identifier. 1 byte
  - v - value can be `27/28` or `2*chainId + 25/36`. `chain id` is identifier of blockchain (need to dive more in this)
